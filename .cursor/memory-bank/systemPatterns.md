# Системные паттерны MoonBit

## Архитектурные принципы

### Общая архитектура
Приложение построено по принципам клиент-серверной архитектуры:
- **Бэкенд**: REST API на Node.js + Express
- **Фронтенд**: SPA на React

### Разделение ответственности
- **Клиент**: отвечает за отображение данных и взаимодействие с пользователем
- **Сервер**: отвечает за обработку запросов, получение данных из внешних API, валидацию и кэширование

## Ключевые паттерны проектирования

### Серверная часть

#### Сервисный слой (Service Layer)
- Каждая функциональная область выделена в отдельный сервис (BitcoinService, MoonService, AstroService, EventsService)
- Сервисы инкапсулируют всю бизнес-логику и взаимодействие с внешними API
- Реализованы как синглтоны

```javascript
// Пример: Синглтон сервис
class BitcoinService {
  // Методы и свойства
}

module.exports = new BitcoinService();
```

#### Фасад (Facade)
- DataSyncService выступает фасадом, координирующим работу других сервисов
- Скрывает сложность взаимодействия между различными компонентами
- Предоставляет единую точку входа для синхронизации данных

```javascript
// Пример: Фасад для синхронизации данных
async syncAll() {
  await Promise.all([
    this.syncBitcoinData(),
    this.syncMoonData(),
    this.syncAstroData(),
    this.syncEventsData()
  ]);
}
```

#### Middleware (Chain of Responsibility)
- Обработка запросов через цепочку middleware (логирование, валидация, обработка ошибок)
- Каждое middleware решает одну конкретную задачу

```javascript
// Пример: Цепочка middleware
app.use(cors());
app.use(express.json());
app.use(requestLogger);
// Маршруты
app.use(notFoundHandler);
app.use(errorHandler);
```

#### Repository
- Сервисы используют файловую систему как хранилище для кэширования данных
- Абстрагирование работы с хранилищем через методы loadCache/saveCache

```javascript
// Пример: Repository паттерн для кэша
loadCache(filePath, defaultValue) {
  try {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }
  } catch (error) {
    logger.error(`Ошибка при загрузке кэша`, { error });
  }
  return defaultValue;
}
```

### Клиентская часть

#### Компонентная архитектура
- UI разделен на переиспользуемые компоненты
- Компоненты имеют четкую ответственность и минимальную связанность

#### Контейнер / Презентационные компоненты
- Компоненты разделены на контейнеры (содержат логику) и презентационные (отображение)
- Dashboard является контейнером, внутри которого находятся презентационные компоненты

#### Композиция компонентов
- Построение сложных компонентов через композицию более простых
- Использование children для гибкой структуры

```jsx
// Пример: Композиция через children
<ErrorBoundary>
  <Dashboard>
    <CurrentPrice />
    <MoonPhaseDisplay />
  </Dashboard>
</ErrorBoundary>
```

#### Хуки (Hook Pattern)
- Использование React-хуков для управления состоянием и побочными эффектами
- Создание пользовательских хуков для повторного использования логики

```jsx
// Пример: Пользовательский хук
function useBitcoinPrice(currency = 'usd') {
  const [price, setPrice] = useState(null);
  
  useEffect(() => {
    // Логика получения цены
  }, [currency]);
  
  return price;
}
```

## Взаимодействие между компонентами

### Серверная часть

#### API-маршруты и контроллеры
```
Клиент -> API маршруты -> Контроллеры -> Сервисы -> Внешние API/Кэш
```

#### Фоновая синхронизация данных
```
DataSyncService -> Отдельные сервисы -> Внешние API -> Кэш
```

### Клиентская часть

#### Получение и отображение данных
```
API -> Сервисы React -> Контейнеры -> Презентационные компоненты
```

#### Обработка ошибок
```
Компоненты -> ErrorBoundary -> Отображение ошибки/Fallback UI
```

## Паттерны доступа к данным

### Кэширование
- Стратегия TTL (Time-To-Live) с разной длительностью для разных типов данных
- Фоновое обновление кэша при истечении срока действия
- Возврат кэшированных данных при ошибках получения новых

### Lazy Loading
- Отложенная загрузка некритичных данных на клиенте
- Использование Suspense и ErrorBoundary для управления загрузкой

### Оптимистичные обновления
- Обновление UI до получения ответа от сервера
- Откат при ошибке на стороне сервера

## Паттерны обработки ошибок

### Централизованная обработка ошибок на сервере
- Middleware для обработки ошибок
- Логирование ошибок с контекстом
- Структурированный ответ клиенту

### Граница ошибок на клиенте (Error Boundary)
- Предотвращение падения всего приложения при ошибке в компоненте
- Fallback UI для компонентов с ошибками

```jsx
// Пример: Использование ErrorBoundary
<ErrorBoundary fallback={<ErrorMessage />}>
  <ComponentThatMightFail />
</ErrorBoundary>
```

## Общие принципы и соглашения

### Именование
- camelCase для переменных и функций в JavaScript
- PascalCase для компонентов React и классов
- kebab-case для CSS-классов и файлов CSS
- UPPER_CASE для констант

### Структура файлов
- Группировка по функциональности (feature-based)
- Разделение бизнес-логики и представления
- Совместное размещение тестов и компонентов 