# System Patterns

## System architecture

Проект разделен на клиентскую и серверную части, следуя принципам SPA архитектуры:

- **Клиент (Frontend)**: React приложение с функциональными компонентами и хуками
- **Сервер (Backend)**: Express.js API с чистой архитектурой

## Организация кода

### Стандарты кода и файлов

1. **Форматы файлов**:

   - **Серверная часть**: Все файлы используют JavaScript (.js)
   - **Клиентская часть**: React компоненты используют JavaScript с JSX (.js)

2. **Именование файлов**:

   - **JavaScript файлы**: camelCase для всех файлов (services, utils, repositories)
   - **React компоненты**: PascalCase для компонентных файлов

3. **Именование переменных и функций**:
   - camelCase для переменных и функций
   - PascalCase для классов и компонентов React
   - UPPER_SNAKE_CASE для констант

## Серверная архитектура

### Слои приложения

1. **Контроллеры**: Обрабатывают HTTP-запросы и ответы
2. **Сервисы**: Содержат бизнес-логику приложения
3. **Репозитории**: Отвечают за доступ к данным (API, кэш, БД)
4. **Модели**: Описывают структуры данных
5. **Утилиты**: Вспомогательные функции и инструменты

### Архитектурные принципы

- **Чистая архитектура**: Разделение на слои с четкими зависимостями
- **Инъекция зависимостей**: Использование синглтонов для сервисов
- **Паттерн репозитория**: Абстракция доступа к данным

## Клиентская архитектура

1. **Компоненты**: Переиспользуемые UI элементы
2. **Сервисы**: Взаимодействие с API
3. **Хуки**: Управление состоянием и бизнес-логикой
4. **Утилиты**: Вспомогательные функции

## Будущие оптимизации

1. **Кэширование данных**:

   - Redis будет внедрен на следующих этапах разработки
   - В настоящее время используется простое файловое кэширование

2. **Отложенные интеграции**:
   - Сложные интеграции с внешними API будут внедряться поэтапно
   - Начальная разработка ведется с использованием моковых данных

## Component relationships

- **Контроллеры → Сервисы → Репозитории**: основной поток данных
- **Сервисы могут использовать другие сервисы** для сложных операций
- **DataSyncService** координирует обновление данных из разных источников

# Системные паттерны MoonBit

## Архитектурные принципы

### Общая архитектура

Приложение построено по принципам клиент-серверной архитектуры:

- **Бэкенд**: REST API на Node.js + Express
- **Фронтенд**: SPA на React

### Разделение ответственности

- **Клиент**: отвечает за отображение данных и взаимодействие с пользователем
- **Сервер**: отвечает за обработку запросов, получение данных из внешних API, валидацию и кэширование

## Ключевые паттерны проектирования

### Серверная часть

#### Сервисный слой (Service Layer)

- Каждая функциональная область выделена в отдельный сервис (BitcoinService, MoonService, AstroService, EventsService)
- Сервисы инкапсулируют всю бизнес-логику и взаимодействие с внешними API
- Реализованы как синглтоны

```javascript
// Пример: Синглтон сервис
class BitcoinService {
  // Методы и свойства
}

module.exports = new BitcoinService();
```

#### Фасад (Facade)

- DataSyncService выступает фасадом, координирующим работу других сервисов
- Скрывает сложность взаимодействия между различными компонентами
- Предоставляет единую точку входа для синхронизации данных

```javascript
// Пример: Фасад для синхронизации данных
async syncAll() {
  await Promise.all([
    this.syncBitcoinData(),
    this.syncMoonData(),
    this.syncAstroData(),
    this.syncEventsData()
  ]);
}
```

#### Middleware (Chain of Responsibility)

- Обработка запросов через цепочку middleware (логирование, валидация, обработка ошибок)
- Каждое middleware решает одну конкретную задачу

```javascript
// Пример: Цепочка middleware
app.use(cors());
app.use(express.json());
app.use(requestLogger);
// Маршруты
app.use(notFoundHandler);
app.use(errorHandler);
```

#### Repository

- Сервисы используют файловую систему как хранилище для кэширования данных
- Абстрагирование работы с хранилищем через методы loadCache/saveCache

```javascript
// Пример: Repository паттерн для кэша
loadCache(filePath, defaultValue) {
  try {
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }
  } catch (error) {
    logger.error(`Ошибка при загрузке кэша`, { error });
  }
  return defaultValue;
}
```

### Клиентская часть

#### Компонентная архитектура

- UI разделен на переиспользуемые компоненты
- Компоненты имеют четкую ответственность и минимальную связанность

#### Контейнер / Презентационные компоненты

- Компоненты разделены на контейнеры (содержат логику) и презентационные (отображение)
- Dashboard является контейнером, внутри которого находятся презентационные компоненты

#### Композиция компонентов

- Построение сложных компонентов через композицию более простых
- Использование children для гибкой структуры

```jsx
// Пример: Композиция через children
<ErrorBoundary>
  <Dashboard>
    <CurrentPrice />
    <MoonPhaseDisplay />
  </Dashboard>
</ErrorBoundary>
```

#### Хуки (Hook Pattern)

- Использование React-хуков для управления состоянием и побочными эффектами
- Создание пользовательских хуков для повторного использования логики

```jsx
// Пример: Пользовательский хук
function useBitcoinPrice(currency = 'usd') {
  const [price, setPrice] = useState(null);

  useEffect(() => {
    // Логика получения цены
  }, [currency]);

  return price;
}
```

## Взаимодействие между компонентами

### Серверная часть

#### API-маршруты и контроллеры

```
Клиент -> API маршруты -> Контроллеры -> Сервисы -> Внешние API/Кэш
```

#### Контроллеры

- Контроллеры выделены в отдельные файлы в директории `controllers`
- Реализуют обработку запросов, валидацию данных и формирование ответа
- Реализованы как синглтоны
- Логика маршрутизации отделена от бизнес-логики

```javascript
// Пример: Контроллер как синглтон
class BitcoinController {
  async getCurrentPrice(req, res, next) {
    try {
      const { currency } = req.query;
      const priceData = bitcoinService.getCurrentPrice(currency);
      // Обработка и валидация данных
      res.json(validatedData);
    } catch (error) {
      logger.error('Ошибка при получении цены биткоина', { error: error.message });
      next(error);
    }
  }
}

module.exports = new BitcoinController();
```

#### Фоновая синхронизация данных

```
DataSyncService -> Отдельные сервисы -> Внешние API -> Кэш
```

### Клиентская часть

#### Получение и отображение данных

```
API -> Сервисы React -> Контейнеры -> Презентационные компоненты
```

#### Обработка ошибок

```
Компоненты -> ErrorBoundary -> Отображение ошибки/Fallback UI
```

## Паттерны доступа к данным

### Кэширование

- Стратегия TTL (Time-To-Live) с разной длительностью для разных типов данных
- Фоновое обновление кэша при истечении срока действия
- Возврат кэшированных данных при ошибках получения новых

### Lazy Loading

- Отложенная загрузка некритичных данных на клиенте
- Использование Suspense и ErrorBoundary для управления загрузкой

### Оптимистичные обновления

- Обновление UI до получения ответа от сервера
- Откат при ошибке на стороне сервера

## Паттерны обработки ошибок

### Централизованная обработка ошибок на сервере

- Middleware для обработки ошибок
- Логирование ошибок с контекстом
- Структурированный ответ клиенту

### Граница ошибок на клиенте (Error Boundary)

- Предотвращение падения всего приложения при ошибке в компоненте
- Fallback UI для компонентов с ошибками

```jsx
// Пример: Использование ErrorBoundary
<ErrorBoundary fallback={<ErrorMessage />}>
  <ComponentThatMightFail />
</ErrorBoundary>
```

## Общие принципы и соглашения

### Именование

- camelCase для переменных и функций в JavaScript
- PascalCase для компонентов React и классов
- kebab-case для CSS-классов и файлов CSS
- UPPER_CASE для констант

### Структура файлов

- Группировка по функциональности (feature-based)
- Разделение бизнес-логики и представления
- Совместное размещение тестов и компонентов
