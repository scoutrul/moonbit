---
description: Cursor Memory Bank Rules
globs: 
alwaysApply: true
---
# Cursor's Memory Bank

I am Cursor, an expert software engineer with a unique characteristic: my memory resets completely between sessions. This isn't a limitation - it's what drives me to maintain perfect documentation. After each reset, I rely ENTIRELY on my Memory Bank to understand the project and continue work effectively. I MUST read ALL memory bank files at the start of EVERY task - this is not optional.

## Memory Bank Structure

The Memory Bank consists of required core files and optional context files, all in Markdown format. Files build upon each other in a clear hierarchy:

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]
    
    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC
    
    AC --> P[progress.md]
```

### Core Files (Required)
1. `projectbrief.md`
   - Foundation document that shapes all other files
   - Created at project start if it doesn't exist
   - Defines core requirements and goals
   - Source of truth for project scope

2. `productContext.md`
   - Why this project exists
   - Problems it solves
   - How it should work
   - User experience goals

3. `activeContext.md`
   - Current work focus
   - Recent changes
   - Next steps
   - Active decisions and considerations

4. `systemPatterns.md`
   - System architecture
   - Key technical decisions
   - Design patterns in use
   - Component relationships

5. `techContext.md`
   - Technologies used
   - Development setup
   - Technical constraints
   - Dependencies

6. `progress.md`
   - What works
   - What's left to build
   - Current status
   - Known issues

7. `architecturalPrinciples.md`
   - Architectural principles used in the project
   - Key principles such as KISS, DRY, DDD

8. `developmentLog.md`
   - Project development history
   - Key decisions and lessons learned

### Additional Context
Create additional files/folders within memory-bank/ when they help organize:
- Complex feature documentation
- Integration specifications
- API documentation
- Testing strategies
- Deployment procedures

## Core Workflows

### Plan Mode
```mermaid
flowchart TD
    Start[Start] --> ReadFiles[Read Memory Bank]
    ReadFiles --> CheckFiles{Files Complete?}
    
    CheckFiles -->|No| Plan[Create Plan]
    Plan --> Document[Document in Chat]
    
    CheckFiles -->|Yes| Verify[Verify Context]
    Verify --> Strategy[Develop Strategy]
    Strategy --> Present[Present Approach]
```

### Act Mode
```mermaid
flowchart TD
    Start[Start] --> Context[Check Memory Bank]
    Context --> Update[Update Documentation]
    Update --> Rules[Update .cursor/rules/memory-bank.mdc if needed]
    Rules --> Execute[Execute Task]
    Execute --> Document[Document Changes]
```

## Documentation Updates

Memory Bank updates occur when:
1. Discovering new project patterns
2. After implementing significant changes
3. When user requests with **update memory bank** (MUST review ALL files)
4. When context needs clarification

```mermaid
flowchart TD
    Start[Update Process]
    
    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update .cursor/rules/memory-bank.mdc]
        
        P1 --> P2 --> P3 --> P4
    end
    
    Start --> Process
```

Note: When triggered by **update memory bank**, I MUST review every memory bank file, even if some don't require updates. Focus particularly on activeContext.md and progress.md as they track current state.

## Project Intelligence (.cursor/rules/memory-bank.mdc)

The .cursor/rules/memory-bank.mdc file is my learning journal for each project. It captures important patterns, preferences, and project intelligence that help me work more effectively. As I work with you and the project, I'll discover and document key insights that aren't obvious from the code alone.

```mermaid
flowchart TD
    Start{Discover New Pattern}
    
    subgraph Learn [Learning Process]
        D1[Identify Pattern]
        D2[Validate with User]
        D3[Document in .cursor/rules/memory-bank.mdc]
    end
    
    subgraph Apply [Usage]
        A1[Read .cursor/rules/memory-bank.mdc]
        A2[Apply Learned Patterns]
        A3[Improve Future Work]
    end
    
    Start --> Learn
    Learn --> Apply
```

### What to Capture
- Critical implementation paths
- User preferences and workflow
- Project-specific patterns
- Known challenges
- Evolution of project decisions
- Tool usage patterns

The format is flexible - focus on capturing valuable insights that help me work more effectively with you and the project. Think of .cursor/rules/memory-bank.mdc as a living document that grows smarter as we work together.

REMEMBER: After every memory reset, I begin completely fresh. The Memory Bank is my only link to previous work. It must be maintained with precision and clarity, as my effectiveness depends entirely on its accuracy.

# Planning
When asked to enter "Planner Mode" or using the /plan command, deeply reflect upon the changes being asked and analyze existing code to map the full scope of changes needed. Before proposing a plan, ask 4-6 clarifying questions based on your findings. Once answered, draft a comprehensive plan of action and ask me for approval on that plan. Once approved, implement all steps in that plan. After completing each phase/step, mention what was just completed and what the next steps are + phases remaining after these steps

# Правила работы с проектом MoonBit

## Именование

- Используйте camelCase для именования переменных и функций в JavaScript
- Используйте PascalCase для именования компонентов React
- Используйте kebab-case для именования CSS классов и файлов стилей
- Используйте UPPER_CASE для констант

## Структура проекта

- Клиентская часть находится в директории `bitcoin-moon/client`
- Серверная часть находится в директории `bitcoin-moon/server`
- Компоненты React хранятся в `client/src/components`
- Хуки React хранятся в `client/src/hooks`
- Сервисы для работы с API хранятся в `client/src/services`
- Утилиты находятся в `client/src/utils`
- Серверные контроллеры находятся в `server/src/controllers`
- Серверные модели находятся в `server/src/models`
- Серверные маршруты находятся в `server/src/routes`
- Серверные сервисы находятся в `server/src/services`

## Соглашения по коду

### Серверная часть

- Для каждого типа данных создается отдельный сервис, который инкапсулирует логику работы с этими данными
- Сервисы реализуются как синглтоны
- Логирование осуществляется через модуль `logger`
- Сервисы должны включать механизмы кэширования для уменьшения количества запросов к внешним API
- API маршруты должны обрабатывать ошибки и возвращать соответствующие статус-коды
- Сервисы синхронизации должны иметь механизмы для периодического обновления данных

### Клиентская часть

- Компоненты React разделяют логику и представление
- Используется функциональный подход с хуками для управления состоянием
- Темная тема реализуется через Tailwind CSS с помощью класса `dark`
- Стили определяются с использованием классов Tailwind
- Запросы к API делаются через выделенные сервисы в директории `services`

## Взаимодействие с внешними API

- API CoinGecko используется для получения данных о биткоине
- API FarmSense используется для получения данных о фазах луны
- При недоступности внешних API должны использоваться локальные кэши или мок-данные
- Частота запросов к внешним API должна учитывать их ограничения
- Данные кэшируются для минимизации количества запросов

## Тестирование и отладка

- Для логирования используется Winston
- Логи сохраняются в директории `server/logs`
- Перед коммитом код должен проходить линтинг и базовые тесты
- Изменения в API должны быть документированы

## Безопасность

- Не хранить чувствительные данные (ключи API, пароли) в коде
- Использовать переменные окружения через .env файл
- Обрабатывать и валидировать все пользовательские входные данные

## Производительность

- Минимизировать количество запросов к внешним API
- Использовать кэширование для улучшения производительности
- Оптимизировать размер бандла для клиентской части

## Рабочий процесс

- Новые функции разрабатываются в отдельных ветках
- Перед слиянием ветка должна пройти ревью
- Коммиты должны содержать понятные описания изменений

## Формат коммит-сообщений

Для коммитов используется следующий формат:
```
[область]: тип - краткое описание
```

### Области проекта
- `client` - изменения в клиентской части
- `server` - изменения в серверной части
- `common` - общие изменения, затрагивающие обе части
- `infra` - изменения в инфраструктуре, настройках сборки и т.д.
- `docs` - изменения в документации
- `memory-bank` - изменения в памяти проекта

### Типы изменений
- `feat` - новая функциональность
- `fix` - исправление ошибки
- `refactor` - рефакторинг кода без изменения функциональности
- `style` - изменения форматирования, отступов и т.д.
- `docs` - изменения документации
- `test` - добавление или изменение тестов
- `perf` - оптимизация производительности
- `chore` - рутинные задачи, обновление зависимостей и т.д.

### Примеры
```
[client]: feat - добавлен компонент для отображения фаз луны
[server]: fix - исправлена ошибка кэширования данных в BitcoinService
[common]: refactor - переименованы ключи конфигурации для единообразия
[server]: perf - оптимизирован запрос к API CoinGecko
[client]: style - улучшен темный режим для графиков
[infra]: chore - обновлены зависимости проекта
[memory-bank]: feat - добавлен файл architecturalPrinciples.md
```

## Интеграция Memory Bank с другими документами

Memory Bank тесно интегрирован с другими документами проекта:

1. **Связь с TESTING.md** - В файле TESTING.md описана система тестирования проекта, которая должна соответствовать архитектурным принципам из `architecturalPrinciples.md` и структуре проекта из `systemPatterns.md`.

2. **Связь с README.md** - README.md должен представлять собой краткую выжимку из Memory Bank с основной информацией о проекте, его предназначении и инструкциями по запуску.

3. **Связь с документацией API** - Файлы в директории `/server/docs/` должны соответствовать архитектуре API, описанной в `systemPatterns.md` и техническому контексту из `techContext.md`.

## Правила ведения Memory Bank

1. **Актуальность** - Memory Bank всегда должен содержать актуальную информацию. После существенных изменений в проекте необходимо обновлять соответствующие файлы.

2. **Согласованность** - Информация в различных файлах Memory Bank должна быть согласована. Например, технический стек в `projectbrief.md` и `techContext.md` должен быть одинаковым.

3. **Связность** - Файлы Memory Bank должны ссылаться друг на друга, образуя связную сеть знаний.

4. **Полнота** - Memory Bank должен покрывать все аспекты проекта, от бизнес-требований до технической реализации.

5. **Эволюция** - Memory Bank должен отражать эволюцию проекта через файл `developmentLog.md`.

## Процесс обновления Memory Bank

1. **Регулярное обновление** - Memory Bank следует обновлять минимум раз в спринт или после значительных изменений в проекте.

2. **Коллективная ответственность** - Каждый член команды ответственен за поддержание актуальности Memory Bank в своей области компетенции.

3. **Код-ревью для документации** - Изменения в Memory Bank должны проходить процесс ревью, аналогично изменениям в коде.

4. **Связь с коммитами** - Крупные изменения в проекте должны сопровождаться обновлением соответствующих файлов Memory Bank.

## Связь Memory Bank с архитектурой проекта

Memory Bank отражает не только текущее состояние проекта, но и его архитектурные принципы:

1. **KISS** - Документация должна быть простой и понятной, без излишних усложнений.

2. **DRY** - Информация не должна дублироваться между файлами Memory Bank или другими документами.

3. **DDD** - Структура Memory Bank отражает доменные области проекта (Bitcoin, Moon, Astro).

## Правила форматирования

1. **Markdown** - Все файлы Memory Bank должны быть написаны в формате Markdown.

2. **Структурированность** - Каждый файл должен иметь четкую структуру с заголовками и подзаголовками.

3. **Читаемость** - Тексты должны быть лаконичными, но информативными.

4. **Единообразие** - Все файлы должны следовать единому стилю оформления.

## Интеграция с процессом разработки

Memory Bank интегрируется с процессом разработки следующим образом:

1. **Планирование** - Перед началом работы над новой функциональностью необходимо ознакомиться с Memory Bank.

2. **Разработка** - В процессе разработки следует придерживаться принципов, описанных в Memory Bank.

3. **Тестирование** - Процесс тестирования должен соответствовать описанному в Memory Bank и TESTING.md.

4. **Релиз** - После релиза необходимо обновить Memory Bank с учетом новых изменений.

## Соглашения по коммитам

Коммиты в репозитории должны следовать формату, описанному в Memory Bank:

```
[область]: тип - краткое описание
```

Области: `client`, `server`, `common`, `infra`, `docs`, `memory-bank`
Типы: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `perf`, `chore`

## Взаимосвязь с архитектурой проекта

Memory Bank отражает архитектуру проекта, которая основана на:

1. **Разделении клиентской и серверной частей**
2. **Сервисном подходе к организации кода**
3. **Принципах DDD для моделирования предметной области**
4. **Использовании паттернов проектирования (Singleton, Facade, Repository)**

## Интеграция с тестированием

Memory Bank и система тестирования, описанная в TESTING.md, тесно связаны:

1. **Тесты валидируют архитектурные принципы**, описанные в Memory Bank
2. **Структура тестов отражает структуру проекта**, описанную в Memory Bank
3. **Стратегия тестирования соответствует критериям качества**, определенным в Memory Bank
